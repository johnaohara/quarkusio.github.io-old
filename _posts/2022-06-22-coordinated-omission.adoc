---
layout: post
date:   2022-06-17 00:00 +0100
author: johara
tags: performance
title: "What is Coordinated Omission?"
synopsis: 
---
:imagesdir: /assets/images/posts/coordinated-omission

Learn about Coordinated Omission. What is Coordinated Omission? How does it effect benchmark results and how can we design a test that does not suffer from coordinated omission.

== Tl;dr

Coordinated Omission occurs when the load generator we choose is not able to accurately create a workload representative of real world traffic when load testing a Web service. 

There is a "Coordination" from the System Under Test applying indirect back pressure to the load driver, that causes the load driver to "Omit" any number of valid results.

Response time metrics measured with tools that suffer from Coordinated Omission are far from misleading, they are wrong. The worst part is, the load generator can not detect or inform users that the results are incorrect.

Using tools such as https://hyperfoil.io/[Hyperfoil], you can be sure that any response time metrics it captures are accurate; or, if it detects back-pressure from the System Under Test, it will record and report the unintended back-pressure.

== Relevant Articles

Coordinated Omission is a term that has been in circulation for a while now and there are many articles that describe

For more information, please visit the following articles;

- http://highscalability.com/blog/2015/10/5/your-load-generator-is-probably-lying-to-you-take-the-red-pi.html



== Tell me about this Coordinated Omission thingy!

Before exploring the nuances of coordinated omission, lets get clear in our minds what it is we are trying to do when we are measuring system "response time".

Imagine a scenario where we run a call center for a building materials trade counter (*Building Star Trade Supplies Inc*)

Our tag line is "*_Building Star Trade Supplies Inc: the best in the world for all your building supply needs!_*"

To improve customer experience, we want to reduce the time it takes for our customers to place an order. The faster customers can place an order, the happier they are, and the faster we can build a world beating business!

What do we need to do; measure how long it takes to place a telephone order through our switchboard.

If it takes longer than 3 minutes to place an order we will start to loose market share to our rivals _Prime Materials Supplies_. 

=== A typical interaction

image::customer-interaction.png[Interaction,400,400,float="right",align="center"]

Typically a customer calls the call center, is put through to an operator, where the operator checks stock levels, raises a new order and confirms with the customer before terminating tha call.

=== How long does it take to place an order?

image::coordinated-omission-placeOrder.png[Order timeline]

There are 2 main components in the time taken to place the order;  

* the *"Wait Time"* the customer was being held in the switchboard queue before being put through the operator
* The *"Service Time"* it took for the operator to process the customer request

From the customers point-of-view, the total *"Order Time"* (i.e. the time taken to place the order) was ;

[IMPORTANT]
====
*"Order Time" = "Wait Time" + "Service Time"*

To measure the performance of our call center, we need to measure the total "Order Time".

If it only takes a single operator 30 seconds to process an order request, but customers are waiting on average 30 minutes to be connected to them, the customer experience is poor"
====

== "What does a call center have to do with my Web Service?!?"

There are a lot of similarities between a call center and a Web Service. 

[NOTE]
====
Any number of _customers_ (*clients*) can _call_ (*tcp_socket::open*) our _switchboard_ (*web service*), where an _operator_ (*thread*) will process the _enquiry_ (*request*), interacting with multiple _systems_ (*backend services*) before confirming an _order_ (*response*) and terminating the _call_ (*tcp_socket::close*). 
====

Typically for us developers of web services; before we push our changes into production, we want to know how it will scale or perform under sustained client load. So, we build a benchmark, take some measurements and deploy depending on if we see acceptable performance.

But *how* do we measure performance of a web service? What decisions do we take, and how does this impact our confidence in how our web service performs. 

== Measuring System performance

So, you've been tasked with ensuring the application can handle production workload. The checklist typically looks something like;

* [*] pick a load generation tool
* [*] setup benchmarking environment
* [*] run load generation tool against test environment
* [x] ensure the system response times are within required SLA's
* [ ] ship it!

[IMPORTANT]
====
*The first step is crucial! : Picking a load generation tool that models reality is vital in shipping a product that behaves they way you expecct it to*
====

== Modelling the real world

Let's go back to our *Building Star Trade Supplies Inc*. In order to improve customer experience, we have built a brand new call center *BSTSI-callHandler-2.0*!! 

We have tested to make sure the call center works (*functional testing*); but before we start taking customers calls there, we need to ensure that it is more efficient (*load testing*) than *BSTSI-callHandler-0.1.BETA*.

For this work, we need to design a test that models the real world!

=== Designing the "load" test

Our SLA for our call center stipulates that we need to be able to;

- Process *20 orders per minute*
- Customers must spend *on average less than 3 minutes* on the phone placing an order.

So, lets bring in a number of dummy customers (*clients*) that will ring the call center and place fictitious orders. We can measure how long it takes for each dummy customer to place and order. 

To meet the SLA, we need to be able to process *20 orders per minute* (*throughput*) with the average telephone call taking less than *3 minutes* (*response time*).

=== First attempt

image::firstTest.png[First Test,400,400,float="right",align="center"]

. Each tester is given their own phone and a list of orders to place

. The tester calls the new call center and places an order

. After the call terminates, the tester checks the phone screen to see how the call took, and records this as the "Order Time"

. After all the testers have run through their list of dummy orders. The call times for all the testers are collated 

After reviewing the call logs, we found the average call duration was *1min 20secs*

==== Woohoo!!! Ship It!!




==== What went wrong?

Each tester had been given their own phone and a list of orders to place.  *They can only place one order at a time!*

They are blocked from placing any more orders until their current order is placed.  

In the real world there are many multiple times more customers

In the real world, customers enquiries arrive at different, random times, often in parallel. 

In the real world, there are *hiccups*.  In our call center there are Lunch breaks, fire alarms, computer systems crash. 

=== Second Attempt

. Each tester is given *multiple phones* and a list of orders to place *and the time to start the call*

. The tester(s) calls the new call center to place orders

. If the first call does not complete before the next order needs to be placed, the tester users a *different* phone to make the next call. Any one tester can have multiple calls *running concurrently* at the same time.

. After the call terminates, the tester checks the phone screen to see how the call took, and records this as the "Order Time"

. After all the testers have run through their list of dummy orders. The call times for all the testers are collated and summary data is calculated.

. If the tester runs out of phones, they record how long they did not have any more phones available for.  The sum of this time is the total *blocked time* during the load test.  This is a direct measurement of Coordinated Omission.

=== What is different?

In the first test, the testers could only make one call and made the calls in sequence. 

If there was a hiccup, they could not start a new call.  

== But surely, if I have enough threads, I can tune away this problem?

Unfortunately not, you *might* be able to mitigate some of the issues through tuning, but you can *never be certain that the results are accurate*. The fundamental problem is that there is *missing data*.

== What can be done?

A load generation tool that uses asynchronous I/O and uncouples threading from I/O, which measures timing independent on I/O is able to detect when the System Under Test is applying back-pressure to the load generator.

Tools such as Hyperfoil will detect *and report* backpressure, so you *can* be sure that the load generator is reporting accurate response times without any Coordinated Omission effects from the SUT.


== Summary

